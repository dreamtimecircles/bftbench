searchState.loadedDescShard("arraydeque", 0, "A circular buffer with fixed capacity. Requires Rust 1.59+\nA fixed capacity ring buffer.\nError value indicating insufficient capacity\nDraining <code>ArrayDeque</code> iterator\nBy-value <code>ArrayDeque</code> iterator\n<code>ArrayDeque</code> iterator\n<code>ArrayDeque</code> mutable iterator\n<strong>RangeArgument</strong> is implemented by Rust’s built-in range …\nReturns a pair of slices which contain, in order, the …\nReturns a pair of slices which contain, in order, the …\nEntire capacity of the underlying storage\nEntire capacity of the underlying storage\nProvides a reference to the back element, or <code>None</code> if the …\nProvides a mutable reference to the back element, or <code>None</code> …\nBehavior semantics for <code>ArrayDeque</code>.\nReturn the capacity of the <code>ArrayDeque</code>.\nClears the buffer, removing all values.\nReturns <code>true</code> if the <code>ArrayDeque</code> contains an element equal …\nCreate a draining iterator that removes the specified …\nThe element that caused the error.\nEnd index (exclusive)\nEnd index (exclusive)\nExtend deque from back with the contents of an iterator.\nExtend deque from back with the contents of an iterator.\nExtend deque from front with the contents of an iterator.\nExtend deque from front with the contents of an iterator.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nProvides a reference to the front element, or <code>None</code> if the …\nProvides a mutable reference to the front element, or <code>None</code> …\nRetrieves an element in the <code>ArrayDeque</code> by index.\nRetrieves an element in the <code>ArrayDeque</code> mutably by index.\nInserts an element at <code>index</code> within the <code>ArrayDeque</code>. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the buffer contains no elements\nReturns true if the buffer is full.\nReturns a front-to-back iterator.\nReturns a front-to-back iterator that returns mutable …\nReturns the number of elements in the <code>ArrayDeque</code>.\nMake the buffer contiguous\nCreates an empty <code>ArrayDeque</code>.\nRemoves the last element from a buffer and returns it, or …\nRemoves the first element and returns it, or <code>None</code> if the …\nAppends an element to the back of a buffer\nAdd an element to the back of the deque.\nAdd an element to the front of the deque.\nAdd an element to the front of the deque.\nRemoves and returns the element at <code>index</code> from the …\nRetains only the elements specified by the predicate.\nSplits the collection into two at the given index.\nStart index (inclusive)\nStart index (inclusive)\nSwaps elements at indices <code>i</code> and <code>j</code>.\nRemoves an element from anywhere in the <code>ArrayDeque</code> and …\nRemoves an element from anywhere in the <code>ArrayDeque</code> and …\nMarker trait for indicating behaviors of <code>ArrayDeque</code>.\nBehavior for <code>ArrayDeque</code> that specifies saturating write …\nBehavior for <code>ArrayDeque</code> that specifies wrapping write …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")